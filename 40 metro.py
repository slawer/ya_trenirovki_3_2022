

"""

https://contest.yandex.ru/contest/45468/problems/40

Метрополитен состоит из нескольких линий метро. Все станции метро в городе пронумерованы натуральными числами
от 1 до N. На каждой линии расположено несколько станций. Если одна и та же станция расположена сразу на нескольких
линиях, то она является станцией пересадки и на этой станции можно пересесть с любой линии, которая через нее проходит,
на любую другую (опять же проходящую через нее).

Напишите программу, которая по данному вам описанию метрополитена определит, с каким минимальным числом пересадок
можно добраться со станции A на станцию B. Если данный метрополитен не соединяет все линии в одну систему,
то может так получиться, что со станции A на станцию B добраться невозможно, в этом случае ваша программа должна
это определить.

Формат ввода
Сначала вводится число N — количество станций метро в городе (2≤N≤100). Далее следует число M — количество линий
метро (1≤M≤20). Далее идет описание M линий. Описание каждой линии состоит из числа Pi — количество станций на
этой линии (2≤Pi≤50) и Pi чисел, задающих номера станций, через которые проходит линия
(ни через какую станцию линия не проходит дважды).

Затем вводятся два различных числа: A — номер начальной станции, и B — номер станции, на которую нам нужно попасть.
При этом если через станцию A проходит несколько линий, то мы можем спуститься на любую из них. Так же если через
станцию B проходит несколько линий, то нам не важно, по какой линии мы приедем.

Формат вывода
Выведите минимальное количество пересадок, которое нам понадобится. Если добраться со станции A на станцию
B невозможно, программа должна вывести одно число –1 (минус один).

"""

from collections import defaultdict


n = [int(e) for e in input().split()][0]
m = [int(e) for e in input().split()][0]

d = defaultdict(list)
l = [[] for i in range(m+1)]
for i in range(1, m+1):
    t = [int(e) for e in input().split()]
    for j in range(1, t[0]+1):
        l[i].append(t[j])

for t in l:
    for i in range(len(t)):
        for j in range(i + 1, len(t)):
            d[t[i]].append(t[j])
            d[t[j]].append(t[i])

a, b = [int(e) for e in input().split()]


def bfs():
    s = [a]
    dist[a] = 0
    while s:
        c = s.pop(0)
        r = dist[c]
        for n in d.get(c, []):
            if dist[n] != mm:
                continue

            s.append(n)
            prev[n] = c
            dist[n] = r + 1


mm = 100
dist = [mm for _ in range(n + 1)]
prev = [mm for _ in range(n + 1)]
bfs()

print(-1 if dist[b] == mm else dist[b] - 1)


print(dist)
print(prev)
print(l)
print(d)