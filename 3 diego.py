

"""
https://contest.yandex.ru/contest/45468/problems/3

3. Коллекционер Диего
Ограничение времени	1 секунда
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Диего увлекается коллекционированием наклеек. На каждой из них написано число, и каждый коллекционер мечтает собрать наклейки со всеми встречающимися числами.

Диего собрал N наклеек, некоторые из которых, возможно, совпадают. Как-то раз к нему пришли K коллекционеров. i-й из них собрал все наклейки с номерами не меньшими, чем pi. Напишите программу, которая поможет каждому из коллекционеров определить, сколько недостающих ему наклеек есть у Диего. Разумеется, гостей Диего не интересуют повторные экземпляры наклеек.

Формат ввода
В первой строке содержится единственное число N (0 ≤ N ≤ 100 000) — количество наклеек у Диего.

В следующей строке содержатся N целых неотрицательных чисел (не обязательно различных) — номера наклеек Диего. Все номера наклеек не превосходят 109.

В следующей строке содержится число K (0 ≤ K ≤ 100 000) — количество коллекционеров, пришедших к Диего. В следующей строке содержатся K целых чисел pi (0 ≤ pi ≤ 109), где pi — наименьший номер наклейки, не интересующий i-го коллекционера.

Формат вывода
Для каждого коллекционера в отдельной строке выведите количество различных чисел на наклейках, которые есть у Диего, но нет у этого коллекционера.

Пример 1
Ввод	Вывод
1
5
2
4 6
0
1

"""
'''

ответить на запросы сколько числе из последовательности меньше либо равны заданному

бин поиск
проверить если ли элемент в последовательности

в коллекции - отсортировать и могут быть повторы - их не нужно учесть

избавиться - положить все в множество
затем отсортирвоать
и выполнить поиск

другой варик - 
отсортировать и линейным поиском убрать повторы RLE

'''


def bp(p):

    if nakl_diego[-1] < p:
        return len(nakl_diego)
    if p <= nakl_diego[0]:
        return 0

    l = 0
    r = len(nakl_diego) -1
    while l < r -1:
        s = (l+r) // 2
        if nakl_diego[s] == p:
            return s
        if p < nakl_diego[s]:
            r = s
        else:
            l = s

    return r


n = int(input())
nakl_diego = [int(i) for i in input().split()]

k = int(input())
koll = [int(i) for i in input().split()]

nakl_diego = sorted(list(set(nakl_diego)))


for p in koll:

    e = bp(p)
    print(e)