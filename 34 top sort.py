

"""

https://contest.yandex.ru/contest/45468/problems/34

34. Топологическая сортировка
Ограничение времени	2 секунды
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Дан ориентированный граф. Необходимо построить топологическую сортировку.

Формат ввода
В первой строке входного файла два натуральных числа N и M (1 ≤ N, M ≤ 100 000) — количество вершин и рёбер
в графе соответственно. Далее в M строках перечислены рёбра графа. Каждое ребро задаётся парой чисел — номерами
начальной и конечной вершин соответственно.

Формат вывода
Выведите любую топологическую сортировку графа в виде последовательности номеров вершин (перестановка чисел от 1 до N).
Если топологическую сортировку графа построить невозможно, выведите -1.

"""

"""
за квадрат времени:

ищем одну вершину из которой не выходят ребря
удалем ее и ребра исходящие из нее
повторяем

можно улучшить заменив линейный поиск на кучу или сортировку или в-множествами

но можно довести до асимптотики о от е

можно за счет обхода в глубину
- когда выходим из дфс зхначит прошли по всем достижимым вершинам - обработали и пометили все доступные
выпишем номер вершины на выходе из дфс - они все достижимы были и находятся в списке левее

метим черным когда все соседи уже помечены черным - выписаны

но не забыть запустить дфс для всех вершин - могут быт в разных компонентах связности

итоговый список разворачиваем и все достижимые справа 
это готовая перенумерация вершин

но в реале нужно помечать и серым для поиска циклов


"""

from collections import defaultdict

import sys
sys.setrecursionlimit(100000)

n, m = [int(e) for e in input().split()]

d = defaultdict(list)
for _ in range(m):
    a, b = [int(e) for e in input().split()]
    d[a].append(b)
    # d[b].append(a)

visited = [-1 for _ in range(n+1)]
meeted = []


def dfs(curr):

    visited[curr] = 1
    for neib in d[curr]:
        nc = visited[neib]
        if nc == 1:
            return 0
        elif nc == 2:
            continue

        if 0 == dfs(neib):
            return 0

    visited[curr] = 2
    meeted.append(curr)
    return 1


for node in range(1, n+1):
    if visited[node] != -1:
        continue
    if dfs(node) == 0:
        print(-1)
        exit(0)

for i in range(len(meeted)-1, -1, -1):
    print(meeted[i], end=' ')
print()


print(visited)
print(d)
print(m)



